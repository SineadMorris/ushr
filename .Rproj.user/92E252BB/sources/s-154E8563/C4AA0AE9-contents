---
title: "Additional File 3: \texttt{ushr} performs comparably to nonlinear mixed effects modeling"
author: "Sinead E. Morris, Luise Dziobek-Garrett, Andrew J. Yates"
output: pdf_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = FALSE)

```

This file includes all code used to compare \texttt{ushr} analysis of simulated data with nonlinear effects modeling (NLME). 

## Basic setup

First we load all required packages and define baseline plot settings. Note we perform nonlinear mixed effects modeling using the `saemix` package, we run our algorithms in parallel using the `parallel` package, and we use the `cowplot` and `viridis` packages during plot creation.


```{r packages}
require(ushr)
require(saemix)
require(parallel)
require(cowplot)
require(viridis)

basetext <- 10
basepoint <- 2
baseline <- 1

mytheme <- theme_bw() + theme(axis.text = element_text(size = basetext), 
                              axis.title = element_text(size = basetext + 1),
                              legend.text = element_text(size = basetext), 
                              legend.title = element_blank(),
                              strip.text.x = element_text(size = basetext + 1))

```


## NLME fitting function

Next we define functions needed to fit the NLME model using the \texttt{saemix} package. `get_model()` specifies the biphasic function to be fit by `saemix`; this is required input that must be specified by the user. `do_filter()` filters the raw data so that only individuals that meet our criteria are included in the fitting procedure; this differs from the filtering procedure used by `ushr` in that there is no requirement on the minimum number of observations. `fit_saemix` fits the biphasic function to the filtered data for a specific repetition and resolution type. Finally, `fit_all` applies `fit_saemix` to all resolutions.

```{r function, fig.height = 8, fig.width = 10}

# define Mixed Effects formula for V(t)
get_model <- function(psi, id, x){
  A <- psi[id,1]
  B <- psi[id,2]
  delta <- psi[id,3]
  gamma<- psi[id,4]
  t <- x[,1]
  
  V <- A * exp( - delta * t) + B * exp ( - gamma * t)
  return(V)
}

do_filter <- function(data, detection_threshold = 100, 
                      censortime = 365, decline_buffer = 500, 
                      threshold_buffer = 10){
    
    filtered <- data %>% 
        mutate(vl = case_when(vl <= detection_threshold ~ detection_threshold/2,
                              vl >= detection_threshold ~ vl) ) %>%
        # Look at only those who reach control within user defined censortime
        filter(time <= censortime) %>% group_by(id, simulation, type) %>% 
        filter(any(vl <= detection_threshold)) %>% ungroup() %>%
        # Isolate data from the highest VL measurement (from points 1 - 3) 
        # to the first point below detection
        filter(!is.na(vl)) %>% group_by(id, simulation, type) %>%
        slice(which.max(vl[1:3]):Position(function(x) x <= detection_threshold, vl)) %>% 
        ungroup() %>%
        # Only keep VL sequences that are decreasing with user defined buffer...
        group_by(id, simulation, type) %>% 
        filter(all(vl <= cummin(vl) + decline_buffer)) %>% 
        group_by(id, simulation, type) %>% 
        mutate(n = n(), index = 1:n(), 
               tag = ifelse(vl[n-1] - vl[n] < threshold_buffer, TRUE, FALSE) ) %>%
        filter(!(tag == TRUE & index == n)) %>% 
        ungroup() %>% select(-index, -n, -tag)

    return(filtered)

}

fit_saemix <- function(data0, model){
    data00 <<- data0
    
    saemix_data <- saemixData(name.data = data00, name.group = "id", 
                              name.predictors = "time", name.response = "vl",
                              verbose = FALSE)

    # define starting guess (same as the default guess in ushr )
    guess0 <- c(A = 10000, delta = 0.68, B = 1000, gamma = 0.03)
    
    # construct model
    saemix_model <- saemixModel(model = model, 
                                psi0 = matrix(guess0, ncol = length(guess0), byrow = TRUE, 
                                              dimnames = list(NULL, c("A", "B", "delta", "gamma"))), 
                                error.model = "exponential", transform.par = c(1,1,1,1),
                                verbose = FALSE)
    
    # fit model
    saemix.options <- list(map = TRUE, fim = TRUE, ll.is = FALSE, 
                           displayProgress = FALSE, seed = 1234567,
                           print = FALSE, warnings = FALSE,
                           save = FALSE, save.graphs = FALSE)
    saemix_fit <- saemix(saemix_model, saemix_data, saemix.options)
    
    # get population-level parameters
    poppar <- coef(saemix_fit)$fixed
    
    popse <- saemix_fit["results"]["se.fixed"]
    
    popCI <- data.frame(param = names(poppar), 
                        estimate = signif(poppar, 3), 
                        highCI = signif(poppar + 1.96 * popse,3), 
                        lowCI = signif(poppar - 1.96 * popse,3), 
                        row.names = NULL,stringsAsFactors = FALSE )  %>%
                rbind(., c("1/delta", signif(1/as.numeric(.[3,c(2,4,3)]),3)), 
                         c("1/gamma", signif(1/as.numeric(.[4,c(2,4,3)]),3) ) ) %>%
                mutate(simulation = data0$simulation[1], type = data0$type[1])

    return(popCI)
}

fit_all <- function(i, tmpdata, model){

    tmp <- list()
    types <- unique(tmpdata$type)
    
    for (j in 1:length(types)) {
        data0 <- tmpdata %>% filter(simulation == i, type == types[j])
        
        tmp[[j]] <- fit_saemix(data0 = data0, model = model)
    }
    
    pop <- bind_rows(tmp)
    return(pop)
}
```

## Load simulated data, fit NLME model, and collect output

First we load the simulated data and corresponding parameter estimates from the subset fit using the biphasic model (these can also be generated using code from Additional File 2 with nreps = 100). We then filter the data to identify individuals that adhere to our inclusion criteria.


```{r load}
load("simulated_data.RData")      # loads 'data_all' data.frame
load("simulated_params.RData")    # loads 'data_params' data.frame
load("param_estimates.RData")     # loads 'biphasic' data.frame

filtered <- do_filter(data_all)

```
    
We then run the main function for all repetitions. Note that we run in parallel using `mclapply()` from the `parallel` package; the number of cores can be changed according to user preference and machine capability. The analysis takes some time, so we specify 'nreps = 10' as an example only. To recreate the analysis presented in the main text, one can use the commented out code that uses all repetitions represented in the filtered data.

```{r fits, dependson = "simsetup"}
nreps <- 10
   
#nreps <- max(filtered$simulation)

ncores <- 2

output <- mclapply(1:nreps, mc.cores = ncores, 
                   function(i) fit_all(i, 
                                       tmpdata = filtered, 
                                       model = get_model))

popCI <- output %>% bind_rows()

```


## Process and plot output

### Fig 6: plot deviation scores

To visualize the average deviation values for each parameter and study, we first collect the true mean parameter values used to simulate each dataset and calculate the associated TTS estimates. 


```{r processsaemix, dependson = "fitsaemix"}
allvals <- data_params %>%
    gather(param, true, A:gamma, shortlifespan:logB) %>%
    group_by(simulation, type, param) %>% 
    summarize(true = median(true)) %>%
    ungroup()

saemixvals <- popCI %>% select(-highCI, -lowCI) %>% 
    mutate(estimate = as.numeric(estimate),
           param = ifelse(param == "1/delta", "shortlifespan", param),
           param = ifelse(param == "1/gamma", "longlifespan", param)) %>% 
    left_join(allvals) %>% mutate(analysis = "NLME")

```

```{r processsaemixAlt, dependson = "processsaemix", echo = FALSE, include = FALSE}

saemixvalsFilter <- popCI %>% filter(!is.na(highCI)) %>%
    select(-highCI, -lowCI) %>% 
    mutate(estimate = as.numeric(estimate),
           param = ifelse(param == "1/delta", "shortlifespan", param),
           param = ifelse(param == "1/gamma", "longlifespan", param)) %>% 
    left_join(allvals) %>% mutate(analysis = "NLME")
```


```{r comparesaemix, dependson = "processsaemix"}

compare_data <- biphasic %>% group_by(simulation, type, param) %>% 
    summarize(estimate = median(estimate)) %>%
    ungroup() %>% left_join(allvals) %>% 
    filter(param %in% c("shortlifespan", "longlifespan")) %>%
    distinct(param, estimate, true, simulation, type) %>% 
    mutate(analysis = "individual") %>%
    select(param, estimate, true, simulation, type, analysis)

compareAll <- saemixvals %>%
    select(param, estimate, true, simulation, type, analysis) %>% 
    filter(param %in% c("shortlifespan", "longlifespan")) %>%
    rbind(.,compare_data) %>%
    distinct(param, estimate, true, simulation, type, analysis)

```


```{r plotcompare, dependson = "comparesaemix"}

dummy_long <- data.frame(type = rep(c("high", "intermediate", "low"), each = 4),
                         true = rep(c(18, 75, 18, 75, 18, 75), each = 2), 
                         estimate = rep(c(18, 75, 18, 75, 18, 75), each = 2),
                         analysis = rep(c("NLME", "ODE"), times = 6) )

dummy_short <- data.frame(type = rep(c("high", "intermediate", "low"), each = 4),
                         true = rep(c(1, 15, 1, 15, 1, 15), each = 2), 
                         estimate = rep(c(1, 15, 1, 15, 1, 15), each = 2),
                         analysis = rep(c("NLME", "ODE"), times = 6) )



compareLong <- compareAll %>% filter(param == "longlifespan") %>%
    ggplot() + 
    geom_point(aes(x = true, y = estimate, colour = analysis), 
                           size = 3, alpha = 0.2) + 
    geom_abline(aes(intercept = 0, slope = 1), linetype = "dashed") +
    geom_blank(data = dummy_long, aes(x = true, y = estimate)) +
    facet_wrap(~ type, ncol = 1) + mytheme + 
    ylab("Estimate (fitted subset)") + xlab("True (all subjects)") +
    scale_colour_discrete(name = NULL) + 
    theme(legend.position = c(0.79, 0.82)) +
    guides(color = guide_legend(override.aes = list(alpha = 1)))

compareShort <- compareAll %>% filter(param == "shortlifespan") %>%
    ggplot() + 
    geom_point(aes(x = true, y = estimate, colour = analysis), 
                           size = 3, alpha = 0.2) + 
    geom_abline(aes(intercept = 0, slope = 1), linetype = "dashed") +
    geom_blank(data = dummy_short, aes(x = true, y = estimate)) +
    facet_wrap(~ type, ncol = 1) + mytheme + 
    ylab("Estimate (fitted subset)") + xlab("True (all subjects)") + 
    scale_colour_discrete(guide = FALSE) 

print(
    plot_grid(compareShort, compareLong, 
              labels = c("A", "B"), label_size = 14)
)

```

